---
title: 【给萌新的Python】大作业（1）&补充知识
date: 2017-11-01 00:00:00
author: 张逸霄
categories:
  - Python
tags:
  - 张逸霄
---

布置大作业前，我希望介绍两个结构进行扫尾。

1，列表生成式。

什么是列表生成式呢，简而言之就是，你可以将for循环用一种更为简练的方式表达出来，最后你可以得到一个列表。

<!-- More -->

举个例子，要生成list `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]`可以用`list(range(1, 11))`，

但如果要生成`[1x1, 2x2, 3x3, ..., 10x10]`怎么做？方法一是循环：

![img](【给萌新的Python】大作业（1）&补充知识/img_59f9dcbd9b021.png)

更简单的方法则是使用列表生成式。

![img](【给萌新的Python】大作业（1）&补充知识/img_59f9dce08b1f4.png)

如果循环体非常简单，那么这个方法将会相当有效。

另外，因为Python的for循环可以同时迭代多个变量。比如`dict`的`items()`可以同时迭代key和value：

```
>>> d = {'x': 'A', 'y': 'B', 'z': 'C' }
>>> for k, v in d.items():
```

2，迭代器：

通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。

所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。

生成器的最显著特点是即时演算。

要创建一个generator，有很多种方法。第一种方法很简单，**只要把一个列表生成式的[]改成()**，就创建了一个generator：

```
>>> L = [x * x for x in range(10)]
>>> L
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
>>> g = (x * x for x in range(10))
>>> g
<generator object <genexpr> at 0x1022ef630>
```

创建`L`和`g`的区别仅在于最外层的`[]`和`()`，`L`是一个list，而`g`是一个generator。

generator保存的是算法，每次调用`next(g)`，就计算出`g`的下一个元素的值。

**试一试，创建一个生成器，然后不断调用它。**

------

希望你已经试过了。亲手进行练习非常重要，希望你能重视起来。

当然，我们实际使用的时候，很可能也是用for循环去生成每一个元素。

那么第二种方法生成generator呢？当生成器不方便用列表推导式表示怎么办呢？

如果一个函数定义中包含`yield`关键字，那么这个函数就不再是一个普通函数，而是一个generator：

```
def fib(max):
    n, a, b = 0, 0, 1
    while n < max:
        yield b
        a, b = b, a + b
        n = n + 1
    return 'done'
```

这个函数的yield的意思是：你的函数开始执行，碰到yield的时候返回一个值。再次调用这个函数的时候，从yield这里继续运行（而不是从头）。在这个函数里，我们先初始化了变量，然后进入循环。第一次循环内，返回了b；再一次调用函数时，是从第一次循环开始的，继续执行第一次循环，循环到第二次，yield返回值……

------

3，迭代器

可以被`next()`函数调用并不断返回下一个值的对象称为迭代器：`Iterator`。

生成器都是`Iterator`对象，但`list`、`dict`、`str`虽然是`Iterable`，却不是`Iterator`。

你可能会问，为什么`list`、`dict`、`str`等数据类型不是`Iterator`？

这是因为Python的`Iterator`对象表示的是一个数据流，Iterator对象可以被`next()`函数调用并不断返回下一个数据，直到没有数据时抛出`StopIteration`错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过`next()`函数实现按需计算下一个数据，所以`Iterator`的计算是惰性的，只有在需要返回下一个数据时它才会计算。

`Iterator`甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。

------

大作业：

作业目标：实现基于爬虫数据的数据统计

1，二选一：requests+beautifulsoup或者scrapy爬虫框架。一般来说爬虫框架都是更好的选择，但是相对比较难上手。

2，爬取“豆瓣电影Top 250”页面，并且适当清洗数据格式，将其保存到本地。

3，使用正则表达式（需要一些简单的学习），提取所有电影的年份、国籍；

一个小工具：http://tool.oschina.net/regex

4，进行合适的统计（最好使用pandas等数据分析库，推荐学习），自定分析方法，得出至少三个有用的结论（比如说这些电影最多出现在什么年间，什么国家上榜最多）

加分项：

1，使用了scrapy爬虫框架；

2，分析了超过三项结论（比如说根据词频判断电影类型）

一些说明：

这个大作业希望各位在11月20日之前完成，期间我们还会讲新的知识。

善用搜索引擎，这些Python库都有完整的中文文档。